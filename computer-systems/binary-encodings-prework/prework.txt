1. 
  9 = 0x9
  136 = 0x88
  247 = 0xf7

2. 256^3 = 2^8^3 = 2^24


3. 68656c6c6f20776f726c6420f09f98800a

     0x68      0x65       0x6c     0x6c       0x6f
0110 1000 0110 0101 0110 1100 0110 1100 0110 1111



2. Integers

2.1 Basic conversion

  Dec -> Bin
  4 = 0b100
  65 = 0b1000001
  105 = 0b1101001
  255 = 0b11111111

  uint -> dec
  10 = 2
  11 = 3
  1101100 = 108
  1010101 = 85


2.2 Unsigned binary addition

11111111 + 00001101 = ??

  11111111
+ 00001101
 100001100


  00001100 -> overflow

2.3 Two's complement

127 = 0111 1111 

-128 = 1000 0000

-1 = 1111 1111

1 = 0000 0001

-14 = 1111 0000

2.4

01111111
10000000+
----------------
11111111 = -1 

127 + -128 = -1 yes

negation = flip + 1
-x = ~x + 1
-128 is -128
0 is 0

8bit -> -128
32-bit = -(2^31)
nbit = -(2^[n-1])


2.5 Advanced: Integer overflow detection
if carry in to most significant digit is diff from the carryout, then overflow has occurred


3 Byte ordering

3.1 Itâ€™s over 9000!

big endian


3.2 TCP
af00bc06441e7368eff2a00281ff5600

source port = af00
dest port = bc06
sequence num = 441e 7368
ack num = eff2 a002
data offset = 8

4 bonuse byte ordering


image          format    dimensions     spaceForPixel     dataStart    contents

image1.bmp     bmp      24x48           24                8a           white box/rect

image2.bmp     bmp      32x64           24                8a           red box/rect



5.5 floating point

0 1000 0100 01010100000000000000000

positive

exp = 128 + 4 - 127 = 132 - 127 = 5

M = 1 + 1/4 + 1/16 + 1/64 = 1 + .25 + .0625 + .015625
= 1.328125

= 1.328125 * 2^5 = 42.5

The conversion works by taking advantage of the fact that an int can be converted to an approximate float
since floats cover much much more than the entire range of ints. but maybe not at the same precision.
any int can be approximated by a float to 24 significant digits except 0. 
this meanse we can have an approximation which is either exactly a power of two if the int is already a power of two.
or between the lower and upper power of 2. with the form 1.xxx to tome power of 2.
the lower is 1 *2^E and the upper is 1 * 2^E+1. so we can get the lower by shifting 1 the same as the exponent of the casted float
and the upper by shifting one more. 
we know we don't have to shift one more if the first shift is already equivalent to the original int.

this works upper only. so in the case of negatives we pretend it's a uint. the next highest power toward the positive side is
still valid. -7 goes to -4 for example.

6
snowman

0xE2 0x98 0x83

hello

utf-8

smiley face

echo '0x7' '0x7' '0x7'

snowman = U+2603 = e29883

f09f9880 = U+01f600 = grinning face


